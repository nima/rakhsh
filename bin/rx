#!/usr/bin/env bash
set -uo pipefail

export PATH="/opt/homebrew/bin:${PATH}"

REQUIRED=(nvim timeout)
for req in "${REQUIRED[@]}"; do
  _=$(command -v timeout) || exit 9
done

export TERM='xterm-256color'
export PS4='+ ${BASH_SOURCE}:${LINENO} ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
NVIM="$(command -v nvim)"

export NVIM_APPNAME=rakhsh
CONFIG_DIR="$("$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("config"))' +qa)"
DATA_DIR="$(  "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("data"))'   +qa)"
STATE_DIR="$( "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("state"))'  +qa)"
CACHE_DIR="$( "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("cache"))'  +qa)"

session="${STATE_DIR}/it2sid"
socket="${STATE_DIR}/server.pipe"
export NVIM_LISTEN_ADDRESS="${socket}"
: ${ITERM_SESSION_ID:=headless}
vscode="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"

mkdir -p "$(dirname "${socket}")"

function :clean() {
  rm -f ${CACHE_DIRE}/it2sid
  rm -f "${socket}"
  pkill -9 -f bin/nvim
}

function :debug() {
  printf "#%079d\n" 0 | tr '0' '#'
  echo "Sockets:"
  [[ ! -S "${socket}" ]] || ls -l "${socket}"
  printf "#%079d\n" 0 | tr '0' '-'
  echo "Processes:"
  ps -ef|grep -wE 'n[v]r|n[v]im' || true
  printf "#%079d\n" 0 | tr '0' '#'
}

function :vsc() {
  [[ -x "${vscode}" ]] || return 0

  # code --reuse-window --goto "$(realpath "$1")"
  local -a tokens
  for token in "$@"; do
    tokens+=( "$(realpath "${token}")" )
  done
  open -g -a "Visual Studio Code" --args --reuse-window --goto "${tokens[@]}"

  if [ $# -eq 1 ]; then
    me="$(osascript -e 'tell application "System Events" to get name of first process whose frontmost is true')"
    osascript\
      -e 'tell application "Visual Studio Code" to activate'\
      -e 'tell application "System Events" to keystroke "t" using {command down, option down}'\
    ;
  fi

  osascript -e "tell application \"$me\" to activate"
  return $?
}

function :socket() {
  [[ -S "${socket}" ]] && return 0 || return 1
}

function :alive() {
  :socket || return $?

  timeout 3.0 "$NVIM" --headless --server "${socket}" --remote-expr 0 >/dev/null 2>&1 || return 2
  return 0
}

function :healthy() {
  :alive || return $?
  return 0
}

function :headless() {
  nohup "$NVIM" -V3/tmp/nvim.log --headless --listen "${socket}" </dev/null >/dev/null 2>&1 &
  return 0
}

function :kill() {
  local pid=$1
  [[ -n "${pid}" ]] || return 1
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1

  local i=0
  local s=1
  local -a arrows=( TERM TERM TERM KILL )
  while kill -0 "${pid}" >/dev/null 2>&1; do
    kill -${arrows[i]} "${pid}"
    let i++
    sleep $s
    ((s*=2))
  done
  kill -0 "${pid}" >/dev/null 2>&1 && return 6
  return 0
}

function :boot() {
  :alive && :healthy && return 0

  local pid
  pid=$(:pid 2>/dev/null) && {
    :kill "${pid}" || return $?
  } || true

  rm -f "${socket}"
  :headless
  :wait.block || return $?

  return 0
}

function :pid() {
  :socket || return $?

  local pid
  pid=$("$NVIM" --headless --server "${socket}" --remote-expr 'getpid()' 2>/dev/null) || return 8
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 9

  echo "${pid}"
  return 0
}

function :attach() {
  local clicked=$1
  shift

  local -a tokens=( "$@" )
  #> :vsc "${tokens[@]}"

  local tui tui_attached=0
  tui=$("$NVIM" --headless --server "${socket}" --remote-expr "len(luaeval('vim.api.nvim_list_uis()'))" 2>/dev/null || echo "")
  if [[ "$tui" =~ ^[0-9]+$ ]] && (( tui > 0 )); then
    tui_attached=1
  fi

  local token
  for token in "${tokens[@]}"; do
    echo "${token}" >> /tmp/x
    "$NVIM" --headless --server "${socket}" \
      --remote-send "<Esc>:RakhshOpen ${token}<CR>" || return 11
  done

  return 0
}

function :same() {
  [[ -f "${session}" ]] || return 0

  local recorded
  recorded=$(<"${session}") || return 13  # session file unreadable / invalid

  local current
  current=$(cut -d: -f2 <<< "$ITERM_SESSION_ID") || return 12

  [[ "${current}" == "${recorded}" ]]
  return $?
}

function :mirror.exec() {
  exec nvim --server "${socket}" --remote-ui
}

function :tui() {
  local attached
  attached=$("$NVIM" --headless --server "${socket}" --remote-expr "len(luaeval('vim.api.nvim_list_uis()'))" 2>/dev/null)
  [[ $? -eq 0 ]] || return 14
  (( attached == 0 )) && return 15 || return 0
}

function :tui.exec() {
  # Require a healthy headless server before we even consider a UI.
  :healthy || return $?

  :tui
  local e=$?
  case $e in
    0)
      # At least one UI is already attached to this server.
      # Do not try to grab UI again; files were already attached via :attach.
      return 0
      ;;
	14|15)
      # Either we couldn't query UIs, or there are none yet.
      # In both cases, this terminal may become the UI owner.
      [[ -t 1 ]] || return 0
      exec "$NVIM" --server "${socket}" --remote-ui
      ;;
    *)
      # Unexpected status from :tui; propagate it as an error.
      return $e
      ;;
  esac
}

function :e(){ keyhex=($(echo -n "$1" | xxd -p -c1)); i=0; xxd -p -c1 | while read -r b; do k=${keyhex[$((i%${#keyhex[@]}))]}; printf "%02x\n" $((0x$b ^ 0x$k)); ((i++)); done | xxd -r -p | base64; }

function :d(){ keyhex=($(echo -n "$1" | xxd -p -c1)); i=0; base64 -d | xxd -p -c1 | while read -r b; do k=${keyhex[$((i%${#keyhex[@]}))]}; printf "%02x\n" $((0x$b ^ 0x$k)); ((i++)); done | xxd -r -p; }

function :wait.block() {
  local i=0 max=40
  while (( i < max )); do
    :healthy && return 0
    sleep 0.05
    ((i++))
  done
  return 10
}

#! TODO: clean this shit up; use shopts and take -x|--do-x style flags
: ${TESTING:=}
if [[ ${TESTING} == DUMP ]]; then
  :debug
elif [[ ${TESTING} == CLEAN ]]; then
  :clean
elif [[ -n "${TESTING}" ]]; then
  echo "theirs:$(cat $session) vs ours:$(cut -d: -f2 <<< $ITERM_SESSION_ID)"
  set +e
  echo "acronyms: <iec>: <inherited-error-codes>, <nec>: <native-error-codes>"
  sleep $((0xCAFEBABE/10))&
  sv=$!  #+ Sacrificial virgin
  :debug
  echo;          echo "   <test>      [<iec>] | [<nec>]:  <actual-ec>"
  :clean
  :socket;       echo "   socket           [] | [1]:     $?"
  :alive;        echo "    alive          [1] | [2]:     $?"  #+ 1 from :socket
  :healthy;      echo "  healthy          [1] | [2]:     $?"  #+ 1 from :socket, 2 from :alive
 #:headless;     echo " headless           [] | []:      $?"
  :tui.exec;     echo " tui.exec    [1,2,5,7] | []:      $?"  #+ 1,2 from :healthy, 5,7 from ?
  :kill ${sv};   echo "     kill           [] | [6]:     $?"
  :boot;         echo "     boot          [6] | []:      $?"  #+ 6 from :kill
  :pid;          echo "      pid          [1] | [8,9]:   $?"  #+ 1 from :socket
  :attach;       echo "   attach           [] | [11]:    $?"
  :wait.block;   echo "     wait           [] | [10]:    $?"
  :debug
else
  :boot
  if [[ $# -eq 1 ]] && [[ "$1" == '--mirror' ]]; then
    #+ Mode: CLI
    :mirror.exec
  elif [[ $# -eq 3 ]] && [[ "$1" == '--iterm' ]]; then
    #+ Mode: iTerm
    cd "$2" || exit 99
    let clicked=1
    :attach ${clicked} "${3}"
    :tui.exec  # MAY exec into UI (and writes session on first TTY)
  elif [[ $# -eq 1 ]] && [[ "$1" == '--status' ]] && [[ -S "${socket}" ]]; then
	${NVIM} --server $socket --headless --remote-expr "luaeval('require(\"core.status\").status_summary()')" +qa
  else
    #+ Mode: CLI
    let clicked=0
    :attach ${clicked} "$@"
    :tui.exec  # MAY exec into UI (and writes session on first TTY)
  fi
  exit $?
fi
