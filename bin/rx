#!/usr/bin/env bash
set -uo pipefail

export TERM='xterm-256color'
export PS4='+ ${BASH_SOURCE}:${LINENO} ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
export PATH="/opt/homebrew/bin:${PATH}"
NVIM="$(command -v nvim)"

export NVIM_APPNAME=rakhsh
CONFIG_DIR="$("$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("config"))' +qa)"
DATA_DIR="$(  "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("data"))'   +qa)"
STATE_DIR="$( "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("state"))'  +qa)"
CACHE_DIR="$( "$NVIM" --headless --clean --cmd 'lua io.stdout:write(vim.fn.stdpath("cache"))'  +qa)"

session="${STATE_DIR}/it2sid"
socket="${STATE_DIR}/server.pipe"
export NVIM_LISTEN_ADDRESS="${socket}"
: ${ITERM_SESSION_ID:=headless}
vscode="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"

mkdir -p "$(dirname "${socket}")"

function :clean() {
  rm -f ${CACHE_DIRE}/it2sid
  rm -f "${socket}"
  pkill -9 -f bin/nvim
}

function :debug() {
  printf "#%079d\n" 0 | tr '0' '#'
  echo "Sockets:"
  [[ ! -S "${socket}" ]] || ls -l "${socket}"
  printf "#%079d\n" 0 | tr '0' '-'
  echo "Processes:"
  ps -ef|grep -wE 'n[v]r|n[v]im' || true
  printf "#%079d\n" 0 | tr '0' '#'
}

function :vsc() {
  [[ -x "${vscode}" ]] || return 0

  # code --reuse-window --goto "$(realpath "$1")"
  local -a tokens
  for token in "$@"; do
    tokens+=( "$(realpath "${token}")" )
  done
  open -g -a "Visual Studio Code" --args --reuse-window --goto "${tokens[@]}"

  if [ $# -eq 1 ]; then
    me="$(osascript -e 'tell application "System Events" to get name of first process whose frontmost is true')"
    osascript\
      -e 'tell application "Visual Studio Code" to activate'\
      -e 'tell application "System Events" to keystroke "t" using {command down, option down}'\
    ;
  fi

  osascript -e "tell application \"$me\" to activate"
  return $?
}

function :socket() {
  [[ -S "${socket}" ]] && return 0 || return 1
}

function :alive() {
  :socket || return $?

  timeout 3.0 "$NVIM" --headless --server "${socket}" --remote-expr 0 >/dev/null 2>&1 || return 2
  return 0
}

function :healthy() {
  :alive || return $?
  return 0
}

function :headless() {
  nohup "$NVIM" -V3/tmp/nvim.log --headless --listen "${socket}" </dev/null >/dev/null 2>&1 &
  return 0
}

function :kill() {
  local pid=$1
  [[ -n "${pid}" ]] || return 1
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1

  local i=0
  local s=1
  local -a arrows=( TERM TERM TERM KILL )
  while kill -0 "${pid}" >/dev/null 2>&1; do
    kill -${arrows[i]} "${pid}"
    let i++
    sleep $s
    ((s*=2))
  done
  kill -0 "${pid}" >/dev/null 2>&1 && return 6
  return 0
}

function :boot() {
  :alive && :healthy && return 0

  local pid
  pid=$(:pid 2>/dev/null) && {
    :kill "${pid}" || return $?
  } || true

  rm -f "${socket}"
  :headless
  :wait.block || return $?

  return 0
}

function :pid() {
  :socket || return $?

  local pid
  pid=$("$NVIM" --headless --server "${socket}" --remote-expr 'getpid()' 2>/dev/null) || return 8
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 9

  echo "${pid}"
  return 0
}

function :attach() {
  # iTerm semantic history passes "<file>[:<line>[:<col>]]" as one string.
  local file ln col _
  local -a tokens
  local clicked=0
  if [[ "$1" == '--iterm' ]]; then
    #+ Mode: iTerm
    cd "$2" || return 99
    let clicked=1
    tokens+=( "${3}" )
  elif [[ "$#" -ge 1 ]]; then
    #+ Mode: CLI
    tokens+=( "$@" )
  fi

  [[ ${#tokens[@]} -gt 0 ]] || return 0

  #> :vsc "${tokens[@]}"

  local tui tui_attached=0
  tui=$("$NVIM" --headless --server "${socket}" --remote-expr "len(luaeval('vim.api.nvim_list_uis()'))" 2>/dev/null || echo "")
  if [[ "$tui" =~ ^[0-9]+$ ]] && (( tui > 0 )); then
    tui_attached=1
  fi

  local first=1
  for token in "${tokens[@]}"; do
    IFS=':' read -r file ln col _ <<< "${token}"

    local cmd
    if (( tui )); then
      cmd="tabedit"
    else
      if (( first )); then
        cmd="edit"
      else
        cmd="tabedit"
      fi
    fi

    first=0
    if [[ $ln =~ ^[0-9]+$ ]]; then
      [[ $col =~ ^[0-9]+$ ]] || col=1
      "$NVIM" --headless --server "${socket}" \
        --remote-send "<Cmd>${cmd} ${file} | call cursor(${ln},${col})<CR>" || return 11
    else
      "$NVIM" --headless --server "${socket}" \
        --remote-send "<Cmd>${cmd} ${file}<CR>" || return 11
    fi
  done

  return 0
}

function :same() {
  [[ -f "${session}" ]] || return 0

  local recorded
  recorded=$(<"${session}") || return 13  # session file unreadable / invalid

  local current
  current=$(cut -d: -f2 <<< "$ITERM_SESSION_ID") || return 12

  [[ "${current}" == "${recorded}" ]]
  return $?
}

function :ui() {
  local attached
  attached=$("$NVIM" --headless --server "${socket}" --remote-expr "len(luaeval('vim.api.nvim_list_uis()'))" 2>/dev/null)
  [[ $? -eq 0 ]] || return 14
  (( attached == 0 )) && return 15 || return 0
}

function :ui.exec() {
  # Require a healthy headless server before we even consider a UI.
  :healthy || return $?

  :ui
  local e=$?
  case $e in
    0)
      # At least one UI is already attached to this server.
      # Do not try to grab UI again; files were already attached via :attach.
      return 0
      ;;
    14)
      # :ui could not query the server; fall back to legacy session-based logic.
      ;;
    15)
      # No UI is currently attached: this terminal may become the UI owner.
      [[ -t 1 ]] || return 0
      exec "$NVIM" --server "${socket}" --remote-ui
      ;;
    *)
      # Unexpected status from :ui; propagate it as an error.
      return $e
      ;;
  esac
}

function :wait.block() {
  local i=0 max=40
  while (( i < max )); do
    :healthy && return 0
    sleep 0.05
    ((i++))
  done
  return 10
}

#! TODO: clean this shit up; use shopts and take -x|--do-x style flags
: ${TESTING:=}
if [[ ${TESTING} == DUMP ]]; then
  :debug
elif [[ ${TESTING} == CLEAN ]]; then
  :clean
elif [[ -n "${TESTING}" ]]; then
  echo "theirs:$(cat $session) vs ours:$(cut -d: -f2 <<< $ITERM_SESSION_ID)"
  set +e
  echo "acronyms: <iec>: <inherited-error-codes>, <nec>: <native-error-codes>"
  sleep $((0xCAFEBABE/10))&
  sv=$!  #+ Sacrificial virgin
  :debug
  echo;          echo "   <test>      [<iec>] | [<nec>]:  <actual-ec>"
  :clean
  :socket;       echo "   socket           [] | [1]:     $?"
  :alive;        echo "    alive          [1] | [2]:     $?"  #+ 1 from :socket
  :healthy;      echo "  healthy          [1] | [2]:     $?"  #+ 1 from :socket, 2 from :alive
 #:headless;     echo " headless           [] | []:      $?"
  :ui.exec;      echo "  ui.exec    [1,2,5,7] | []:      $?"  #+ 1,2 from :healthy, 5,7 from ?
  :kill ${sv};   echo "     kill           [] | [6]:     $?"
  :boot;         echo "     boot          [6] | []:      $?"  #+ 6 from :kill
  :pid;          echo "      pid          [1] | [8,9]:   $?"  #+ 1 from :socket
  :attach;       echo "   attach           [] | [11]:    $?"
  :wait.block;   echo "     wait           [] | [10]:    $?"
  :debug
else
  :boot
  [[ "$#" -eq 0 ]] || :attach "$@"
  :ui.exec  # MAY exec into UI (and writes session on first TTY)
  exit $?
fi
